<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FODMAP Diary</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    h1 { margin-bottom: 20px; }
    #textInput { width: 100%; height: 60px; margin-bottom: 10px; font-family: inherit; font-size: inherit; box-sizing: border-box; }
    button { padding: 8px 16px; font-size: 14px; cursor: pointer; }
    .day { margin-bottom: 30px; }
    .day h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-bottom: 5px; }
    .day-ratings { font-size: 14px; margin-bottom: 15px; }
    .day-rating { margin-right: 15px; }
    .entry { margin: 12px 0; display: grid; grid-template-columns: 70px 1fr auto; gap: 0 10px; }
    .time { color: #888; font-size: 13px; font-family: monospace; padding-top: 2px; }
    .entry-content { min-width: 0; }
    .entry-line { display: flex; align-items: baseline; gap: 8px; }
    .text { font-size: 15px; }
    .entry-details { margin-top: 4px; padding-left: 0; }
    .meta { font-size: 13px; color: #444; margin-bottom: 4px; }
    .llm-note { font-style: italic; color: #666; font-size: 13px; }
    .food .entry-content { border-left: 3px solid #4a9; padding-left: 10px; }
    .symptom .entry-content { border-left: 3px solid #e74; padding-left: 10px; }
    .note .entry-content { border-left: 3px solid #88f; padding-left: 10px; }
    .badge {
      display: inline-block; padding: 2px 6px; border-radius: 3px;
      font-weight: 500; font-size: 11px; margin-right: 4px; margin-bottom: 2px;
    }
    .badge-none { background: #d4edda; color: #155724; }
    .badge-low { background: #fff3cd; color: #856404; }
    .badge-medium { background: #ffe0b2; color: #e65100; }
    .badge-high { background: #f8d7da; color: #721c24; }
    .badge-unknown { background: #e0e0e0; color: #666; }
    .badge-note { background: #cce5ff; color: #004085; }
    .badge-safe { background: #c8e6c9; color: #2e7d32; }
    .badge-culprit { background: #ffcdd2; color: #c62828; }
    .tag-btn { background: none; border: 1px solid #ccc; border-radius: 3px; font-size: 14px; padding: 2px 4px; height: 24px; }
    .tag-btn:hover { background: #f0f0f0; }
    .tag-btn.active-safe { background: #c8e6c9; border-color: #2e7d32; color: #2e7d32; }
    .tag-btn.active-culprit { background: #ffcdd2; border-color: #c62828; color: #c62828; }
    .analyze-section { margin: 20px 0; padding: 10px 15px; background: #f8f8f8; border-radius: 4px; font-size: 14px; }
    .analyze-section label { color: #666; margin-right: 5px; }
    .analyze-section input[type="date"] { margin-right: 10px; padding: 4px; }
    .analyze-section button { padding: 5px 12px; }
    #analysis-result { margin-top: 12px; white-space: pre-wrap; font-size: 13px; }
    #analysis-result:empty { display: none; }
    #chart-container { margin: 15px 0; overflow-x: auto; }
    .matrix { border-collapse: separate; border-spacing: 2px; font-size: 11px; }
    .matrix td, .matrix th { padding: 0; }
    .matrix-label { text-align: right; padding-right: 8px !important; color: #666; white-space: nowrap; }
    .matrix-label.symptom-label { font-weight: 600; color: #333; }
    .matrix-cell { width: 16px; height: 16px; border-radius: 2px; }
    .matrix-date { font-size: 9px; text-align: center; padding-top: 4px; }
    .matrix-date a { color: #888; text-decoration: none; }
    .matrix-date a:hover { color: #333; text-decoration: underline; }
    .level-0 { background: #a8e6cf; }
    .level-1 { background: #ffd93d; }
    .level-2 { background: #ffb347; }
    .level-3 { background: #ff6b6b; }
    .actions-col { display: flex; gap: 4px; padding-top: 2px; }
    .delete-btn:hover { color: #e44 !important; }
    .edit-btn { font-size: 12px; }
    
    /* Edit mode */
    .entry.editing .view-mode { display: none; }
    .entry:not(.editing) .edit-form { display: none; }
    .edit-form form { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .edit-dropdowns { display: flex; flex-wrap: wrap; gap: 6px; }
    .factor-edit { display: flex; align-items: center; gap: 4px; font-size: 12px; }
    .factor-label { font-weight: 500; color: #666; min-width: 60px; }
    .factor-select { font-size: 11px; padding: 2px 4px; border: 1px solid #ccc; border-radius: 3px; }
    .save-btn { background: #4a9; color: white; border: none; padding: 4px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; }
    .save-btn:hover { background: #3a8; }
    
    /* Mobile styles */
    @media (max-width: 600px) {
      body { padding: 12px; }
      h1 { font-size: 1.5em; margin-bottom: 15px; }
      
      /* Stack entry: time above content */
      .entry { grid-template-columns: 1fr auto; }
      .time { grid-column: 1 / -1; padding-bottom: 4px; }
      
      /* Form controls wrap */
      form > div { flex-wrap: wrap; gap: 8px; }
      #textInput { height: 50px; }
      
      /* Analyze section stacks */
      .analyze-section { padding: 10px; }
      .analyze-section input[type="date"] { margin-right: 5px; margin-bottom: 8px; }
      
      /* Matrix scrolls horizontally */
      #chart-container { margin: 10px -12px; padding: 0 12px; }
      
      /* Day ratings wrap */
      .day-ratings { display: flex; flex-wrap: wrap; gap: 5px; }
      
      /* Smaller badges */
      .badge { font-size: 10px; padding: 2px 5px; }
      
      /* Bigger touch targets for action buttons */
      .tag-btn { font-size: 18px; padding: 4px 8px; height: 32px; }
      
      /* Edit mode on mobile */
      .edit-dropdowns { gap: 8px; }
      .factor-edit { flex-direction: column; align-items: flex-start; gap: 2px; }
      .factor-label { min-width: auto; }
      .factor-select { font-size: 14px; padding: 4px 8px; }
      .save-btn { padding: 8px 16px; font-size: 14px; }
    }
  </style>
</head>
<body>
  <h1>FODMAP Diary</h1>
  
  <form id="addForm" action="/api/add" method="POST">
    <input type="text" id="textInput" name="text" placeholder="Enter what you ate or how you're feeling..." />
    <div style="margin-bottom: 10px; display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
      <label><input type="checkbox" name="isNote" value="1"> Add as note</label>
      <label><input type="checkbox" id="overrideTime" name="overrideTime" value="1" onchange="toggleTimeInput()"> Override time</label>
      <input type="datetime-local" id="customTime" name="customTime" style="display: none;">
      <button type="submit" id="submitBtn" disabled>Add Entry</button>
    </div>
  </form>
  
  <script>
    function getLocalDateTimeString(date = new Date()) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      return `${year}-${month}-${day}T${hours}:${minutes}`;
    }
    
    function toggleTimeInput() {
      const checkbox = document.getElementById('overrideTime');
      const input = document.getElementById('customTime');
      input.style.display = checkbox.checked ? 'inline' : 'none';
      if (checkbox.checked && !input.value) {
        input.value = getLocalDateTimeString();
      }
    }
    
    // Enter key submits form
    document.getElementById('textInput').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('addForm').requestSubmit();
      }
    });
    
    // Prevent double submission
    document.getElementById('addForm').addEventListener('submit', function() {
      const btn = document.getElementById('submitBtn');
      btn.disabled = true;
      btn.textContent = 'Adding...';
    });
  </script>

  <div class="analyze-section">
    <label>Analyze:</label>
    <input type="date" id="startDate" onchange="updateChart()"> to <input type="date" id="endDate" onchange="updateChart()">
    <button onclick="analyzeEntries()">Find Correlations</button>
    <div id="chart-container"></div>
    <div id="analysis-result"></div>
  </div>

  <div id="diary"></div>

  <script>
    const entries = {{ENTRIES_JSON}};
    const FACTORS = {{FACTORS_JSON}};
    const FACTOR_IDS = {{FACTOR_IDS_JSON}};
    const LEVELS = {{LEVELS_JSON}};
    const SEVERITY_LEVELS = ['low', 'medium', 'high'];
    
    // Group entries by local date
    function getLocalDate(timestamp) {
      const d = new Date(timestamp);
      return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    }
    
    const entriesByDay = {};
    for (const entry of entries) {
      const day = getLocalDate(entry.timestamp);
      if (!entriesByDay[day]) entriesByDay[day] = [];
      entriesByDay[day].push(entry);
    }
    
    function formatTime(timestamp) {
      return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    
    function escapeHtml(str) {
      if (!str) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }
    
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    
    function renderFactors(factors) {
      if (!factors) return '';
      return Object.entries(factors)
        .filter(([_, level]) => level && level !== 'none' && level !== 'unknown')
        .map(([id, level]) => {
          const factor = FACTORS.find(f => f.id === id);
          const displayName = factor ? factor.name : capitalize(escapeHtml(id));
          const safeLevel = escapeHtml(level);
          return `<span class="badge badge-${safeLevel}">${displayName}</span>`;
        })
        .join(' ');
    }
    
    // For backwards compatibility with old entries
    function getFactors(entry) {
      if (entry.factors) return entry.factors;
      // Merge old fodmaps and other into factors
      return { ...entry.fodmaps, ...entry.other };
    }
    
    function renderFactorDropdowns(factors, entryKey) {
      return FACTORS.map(f => {
        const currentLevel = factors?.[f.id] || 'none';
        const options = LEVELS.map(level => 
          `<option value="${level}" ${level === currentLevel ? 'selected' : ''}>${level}</option>`
        ).join('');
        return `
          <label class="factor-edit">
            <span class="factor-label">${f.name}</span>
            <select name="${f.id}" class="factor-select">${options}</select>
          </label>
        `;
      }).join('');
    }
    
    function renderSeverityDropdown(currentSeverity) {
      const options = SEVERITY_LEVELS.map(level => 
        `<option value="${level}" ${level === currentSeverity ? 'selected' : ''}>${level}</option>`
      ).join('');
      return `
        <label class="factor-edit">
          <span class="factor-label">Severity</span>
          <select name="severity" class="factor-select">${options}</select>
        </label>
      `;
    }
    
    async function saveEntry(entryKey, form) {
      const formData = new FormData(form);
      const entry = entries.find(e => e.key === entryKey);
      
      let body = { key: entryKey };
      
      if (entry.type === 'food') {
        const factors = {};
        FACTOR_IDS.forEach(id => {
          factors[id] = formData.get(id);
        });
        body.factors = factors;
      } else if (entry.type === 'symptom') {
        body.severity = formData.get('severity');
      }
      
      try {
        const response = await fetch('/api/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        
        if (response.ok) {
          // Update local entry data
          if (body.factors) entry.factors = body.factors;
          if (body.severity) entry.severity = body.severity;
          renderDiary();
          updateChart();
        } else {
          const error = await response.json();
          alert('Error saving: ' + error.error);
        }
      } catch (err) {
        alert('Error saving: ' + err.message);
      }
    }
    
    async function toggleTag(entryKey, tag) {
      const entry = entries.find(e => e.key === entryKey);
      
      try {
        const response = await fetch('/api/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: entryKey, tag })
        });
        
        if (response.ok) {
          const result = await response.json();
          entry.tag = result.entry.tag;
          renderDiary();
        } else {
          const error = await response.json();
          alert('Error tagging: ' + error.error);
        }
      } catch (err) {
        alert('Error tagging: ' + err.message);
      }
    }
    
    function toggleEdit(entryKey) {
      const entryEl = document.querySelector(`[data-key="${entryKey}"]`);
      const isEditing = entryEl.classList.toggle('editing');
      
      if (isEditing) {
        const entry = entries.find(e => e.key === entryKey);
        const editContainer = entryEl.querySelector('.edit-form');
        
        if (entry.type === 'food') {
          editContainer.innerHTML = `
            <form onsubmit="event.preventDefault(); saveEntry('${entryKey}', this)">
              <div class="edit-dropdowns">${renderFactorDropdowns(getFactors(entry), entryKey)}</div>
              <button type="submit" class="save-btn">Save</button>
            </form>
          `;
        } else if (entry.type === 'symptom') {
          editContainer.innerHTML = `
            <form onsubmit="event.preventDefault(); saveEntry('${entryKey}', this)">
              <div class="edit-dropdowns">${renderSeverityDropdown(entry.severity)}</div>
              <button type="submit" class="save-btn">Save</button>
            </form>
          `;
        }
      }
    }
    
    function renderEntry(entry) {
      const typeClass = escapeHtml(entry.type);
      const time = formatTime(entry.timestamp);
      const safeSeverity = escapeHtml(entry.severity || '');
      const canEdit = entry.type === 'food' || entry.type === 'symptom';
      const isFood = entry.type === 'food';
      
      let badges = '';
      if (entry.type === 'food') {
        badges = renderFactors(getFactors(entry));
        if (entry.tag === 'safe') {
          badges += ` <span class="badge badge-safe">Safe</span>`;
        } else if (entry.tag === 'culprit') {
          badges += ` <span class="badge badge-culprit">Culprit</span>`;
        }
      } else if (entry.type === 'symptom') {
        badges = `<span class="badge badge-${safeSeverity}">Symptoms</span>`;
      } else if (entry.type === 'note') {
        badges = `<span class="badge badge-note">Note</span>`;
      }
      
      const tagButtons = isFood ? `
        <button type="button" class="tag-btn ${entry.tag === 'safe' ? 'active-safe' : ''}" onclick="toggleTag('${entry.key}', 'safe')" title="Mark as safe">✓</button>
        <button type="button" class="tag-btn ${entry.tag === 'culprit' ? 'active-culprit' : ''}" onclick="toggleTag('${entry.key}', 'culprit')" title="Mark as culprit">✗</button>
      ` : '';
      
      return `
        <div class="entry ${typeClass}" data-key="${entry.key}">
          <span class="time">${time}</span>
          <div class="entry-content">
            <div class="text">${escapeHtml(entry.text)}</div>
            <div class="entry-details">
              <div class="meta view-mode">${badges}</div>
              <div class="edit-form"></div>
              ${entry.note ? `<div class="llm-note">${escapeHtml(entry.note)}</div>` : ''}
            </div>
          </div>
          <div class="actions-col">
            ${tagButtons}
            <form action="/api/duplicate" method="POST" style="display:inline">
              <input type="hidden" name="key" value="${entry.key}">
              <button type="submit" class="tag-btn" title="Duplicate at current time">↻</button>
            </form>
            ${canEdit ? `<button type="button" class="tag-btn edit-btn" onclick="toggleEdit('${entry.key}')" title="Edit">✎</button>` : ''}
            <form action="/api/delete" method="POST" style="display:inline" onsubmit="return confirm('Delete this entry?')">
              <input type="hidden" name="key" value="${entry.key}">
              <button type="submit" class="tag-btn delete-btn" title="Delete">×</button>
            </form>
          </div>
        </div>
      `;
    }
    
    const levelOrder = { none: 0, unknown: 0, low: 1, medium: 2, high: 3 };
    
    function getWorstLevel(entries, type, field) {
      const levels = entries
        .filter(e => e.type === type && e[field])
        .map(e => e[field]);
      if (levels.length === 0) return null;
      return levels.reduce((worst, level) => 
        levelOrder[level] > levelOrder[worst] ? level : worst
      );
    }
    
    function getWorstFactorLevel(entries, factorName) {
      const levels = entries
        .filter(e => e.type === 'food')
        .map(e => {
          const factors = getFactors(e);
          return factors?.[factorName];
        })
        .filter(level => level && level !== 'none' && level !== 'unknown');
      if (levels.length === 0) return null;
      return levels.reduce((worst, level) => 
        levelOrder[level] > levelOrder[worst] ? level : worst
      );
    }
    
    function renderDayRatings(dayEntries) {
      const worstSeverity = getWorstLevel(dayEntries, 'symptom', 'severity');
      
      // Get worst level for each factor
      const factorLevels = {};
      FACTOR_IDS.forEach(f => {
        const worst = getWorstFactorLevel(dayEntries, f);
        if (worst) factorLevels[f] = worst;
      });
      
      const hasFactors = Object.keys(factorLevels).length > 0;
      if (!hasFactors && !worstSeverity) return '';
      
      let html = '<div class="day-ratings">';
      
      // Show factors
      Object.entries(factorLevels).forEach(([id, level]) => {
        const factor = FACTORS.find(f => f.id === id);
        const displayName = factor ? factor.name : capitalize(id);
        html += `<span class="badge badge-${level}">${displayName}</span> `;
      });
      
      // Show symptoms
      if (worstSeverity) {
        html += `<span class="badge badge-${worstSeverity}">Symptoms</span>`;
      }
      
      html += '</div>';
      return html;
    }
    
    function renderDiary() {
      const diary = document.getElementById('diary');
      const days = Object.keys(entriesByDay).sort().reverse();
      
      if (days.length === 0) {
        diary.innerHTML = '<p>No entries yet. Add your first entry above!</p>';
        return;
      }
      
      diary.innerHTML = days.map(day => `
        <div class="day" id="day-${day}">
          <h2>${new Date(day + 'T12:00:00').toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</h2>
          ${renderDayRatings(entriesByDay[day])}
          ${entriesByDay[day].map(renderEntry).join('')}
        </div>
      `).join('');
    }
    
    // Derive types from central config
    const rowLabels = ['Symptoms', ...FACTORS.map(f => f.name)];
    const levelNames = ['none', 'low', 'med', 'high'];
    
    function updateChart() {
      const startDate = document.getElementById('startDate').value;
      const endDate = document.getElementById('endDate').value;
      const container = document.getElementById('chart-container');
      
      if (!startDate || !endDate) {
        container.innerHTML = '';
        return;
      }
      
      // Get days in range with their worst levels
      const emptyDay = () => {
        const day = { symptom: 0 };
        FACTOR_IDS.forEach(f => day[f] = 0);
        return day;
      };
      const dayData = {};
      
      entries.forEach(entry => {
        const day = getLocalDate(entry.timestamp);
        if (day >= startDate && day <= endDate) {
          if (!dayData[day]) dayData[day] = emptyDay();
          if (entry.type === 'food') {
            const factors = getFactors(entry);
            if (factors) {
              FACTOR_IDS.forEach(f => {
                if (factors[f]) {
                  dayData[day][f] = Math.max(dayData[day][f], levelOrder[factors[f]] || 0);
                }
              });
            }
          }
          if (entry.type === 'symptom' && entry.severity) {
            dayData[day].symptom = Math.max(dayData[day].symptom, levelOrder[entry.severity] || 0);
          }
        }
      });
      
      const days = Object.keys(dayData).sort();
      if (days.length === 0) {
        container.innerHTML = '<div style="color:#888;font-size:12px;">No data in selected range</div>';
        return;
      }
      
      // Build matrix table
      const rows = ['symptom', ...FACTOR_IDS];
      
      let html = '<table class="matrix">';
      
      // Data rows
      rows.forEach((row, i) => {
        html += '<tr>';
        html += `<th class="matrix-label">${rowLabels[i]}</th>`;
        days.forEach(day => {
          const level = dayData[day][row];
          const title = `${rowLabels[i]}: ${levelNames[level]}`;
          html += `<td><div class="matrix-cell level-${level}" title="${title}"></div></td>`;
        });
        html += '</tr>';
        if (i === 0) {
          html += '<tr>';
          html += '<td style="height:8px;"></td>';
          html += '</tr>';
        }
      });
      
      // Dates row
      html += '<tr><td></td>';
      days.forEach(day => {
        const d = new Date(day + 'T12:00:00');
        const label = `${d.getDate()}`;
        html += `<td class="matrix-date"><a href="#day-${day}">${label}</a></td>`;
      });
      html += '</tr>';
      
      html += '</table>';
      
      // Legend
      html += '<div style="margin-top:10px;font-size:10px;color:#666;">';
      html += '<span style="margin-right:10px;"><span class="matrix-cell level-0" style="display:inline-block;width:10px;height:10px;vertical-align:middle;"></span> None</span>';
      html += '<span style="margin-right:10px;"><span class="matrix-cell level-1" style="display:inline-block;width:10px;height:10px;vertical-align:middle;"></span> Low</span>';
      html += '<span style="margin-right:10px;"><span class="matrix-cell level-2" style="display:inline-block;width:10px;height:10px;vertical-align:middle;"></span> Med</span>';
      html += '<span><span class="matrix-cell level-3" style="display:inline-block;width:10px;height:10px;vertical-align:middle;"></span> High</span>';
      html += '</div>';
      
      container.innerHTML = html;
    }
    
    async function analyzeEntries() {
      const startDate = document.getElementById('startDate').value;
      const endDate = document.getElementById('endDate').value;
      const resultDiv = document.getElementById('analysis-result');
      
      if (!startDate || !endDate) {
        resultDiv.textContent = 'Please select both start and end dates.';
        return;
      }
      
      // Filter entries by local date
      const filteredEntries = entries.filter(entry => {
        const localDate = getLocalDate(entry.timestamp);
        return localDate >= startDate && localDate <= endDate;
      });
      
      resultDiv.textContent = 'Analyzing...';
      
      try {
        const response = await fetch('/api/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ entries: filteredEntries })
        });
        
        const result = await response.json();
        
        if (result.error) {
          resultDiv.textContent = result.error;
          return;
        }
        
        let html = `<strong>Summary:</strong> ${result.summary}\n\n`;
        
        if (result.correlations?.length) {
          html += '<strong>Correlations Found:</strong>\n';
          result.correlations.forEach(c => {
            html += `• ${c.food} → ${c.symptom} (${c.confidence} confidence)\n  ${c.explanation}\n`;
          });
          html += '\n';
        }
        
        if (result.trigger_foods?.length) {
          html += `<strong>Possible Trigger Foods:</strong> ${result.trigger_foods.join(', ')}\n\n`;
        }
        
        if (result.safe_foods?.length) {
          html += `<strong>Well-Tolerated Foods:</strong> ${result.safe_foods.join(', ')}\n\n`;
        }
        
        if (result.recommendations?.length) {
          html += '<strong>Recommendations:</strong>\n';
          result.recommendations.forEach(r => {
            html += `• ${r}\n`;
          });
        }
        
        resultDiv.innerHTML = html;
      } catch (error) {
        resultDiv.textContent = 'Error: ' + error.message;
      }
    }
    
    // Set default date range to last 2 weeks
    const today = new Date().toISOString().split('T')[0];
    const twoWeeksAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    document.getElementById('startDate').value = twoWeeksAgo;
    document.getElementById('endDate').value = today;
    
    renderDiary();
    updateChart();
    
    // Handle submit button state based on textbox content
    const textInput = document.getElementById('textInput');
    const submitBtn = document.getElementById('submitBtn');
    textInput.addEventListener('input', () => {
      submitBtn.disabled = !textInput.value.trim();
    });
    textInput.focus();
  </script>
</body>
</html>

